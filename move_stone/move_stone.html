<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>特殊囲碁 - 対局</title>
  <style>
    body {
      font-family: "Noto Sans JP", sans-serif;
      text-align: center;
      background-color: #f7f3e3;
    }
    #board {
      position: relative;
      margin: 20px auto;
      background-color: #f3d9a3;
      border: 2px solid #000;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }
    .stone {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      position: absolute;
      transform: translate(-50%, -50%);
      transition: 0.2s;
    }
    .black { background-color: black; }
    .white { background-color: white; border: 1px solid #000; }
    #turnPhase { font-size: 24px; margin: 10px; }
    #controls { margin-bottom: 10px; }
    button {
      font-size: 18px;
      padding: 6px 12px;
      margin: 5px;
    }
    #moveControls {
      display: none;
      margin: 15px;
    }
    #moveControls button {
      margin: 4px;
      font-size: 16px;
      padding: 5px 10px;
    }
  </style>
</head>
<body onload="initializeGame()">
  <div id="controls">
    <button onclick="toggleMoveMode()">石移動モード切替</button>
    <button onclick="undo()">⏪ 1手戻す</button>
    <button onclick="goHome()">🏠 ホームへ戻る</button>
  </div>

  <div id="board">
    <canvas id="grid"></canvas>
  </div>

  <div id="moveControls">
    <h3>移動方向を選択</h3>
    <div>
      <button onclick="moveSelectedStone('W')">↑</button>
    </div>
    <div>
      <button onclick="moveSelectedStone('A')">←</button>
      <button onclick="moveSelectedStone('D')">→</button>
    </div>
    <div>
      <button onclick="moveSelectedStone('S')">↓</button>
    </div>
  </div>

  <div id="turnPhase">黒の手番</div>

  <script>
    let SIZE = 19;
    const CELL = 30;
    const OFFSET = CELL;
    let board = [];
    let selectedStone = null;
    let moveMode = false;
    let moveCount = 0; // 1ターン中の移動回数
    let turnCounter = 0;
    let history = [];

    function goHome() {
      if (confirm("対局を終了してホームへ戻りますか？")) {
        window.location.href = "title.html";
      }
    }

    function getBoardSizeFromURL() {
      const params = new URLSearchParams(window.location.search);
      const size = parseInt(params.get("size")) || 19;
      return [9, 13, 19].includes(size) ? size : 19;
    }

    function initializeGame() {
      SIZE = getBoardSizeFromURL();
      initializeBoard();
    }

    function initializeBoard() {
      board = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
      setupCanvas();
      drawGrid();
      drawBoard();
    }

    function setupCanvas() {
      const boardDiv = document.getElementById("board");
      const canvas = document.getElementById("grid");
      const length = (SIZE - 1) * CELL + OFFSET * 2 - CELL;
      boardDiv.style.width = length + "px";
      boardDiv.style.height = length + "px";
      canvas.width = length;
      canvas.height = length;
    }

    function drawGrid() {
      const canvas = document.getElementById("grid");
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#555";
      ctx.lineWidth = 1;
      const length = (SIZE - 1) * CELL + OFFSET * 2 - CELL;

      for (let i = 0; i < SIZE; i++) {
        const pos = OFFSET + i * CELL;
        ctx.beginPath();
        ctx.moveTo(OFFSET, pos);
        ctx.lineTo(length - OFFSET + CELL, pos);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(pos, OFFSET);
        ctx.lineTo(pos, length - OFFSET + CELL);
        ctx.stroke();
      }
      drawStars(ctx);
    }

    function drawStars(ctx) {
      ctx.fillStyle = "#000";
      let starCoords = [];
      if (SIZE === 9) starCoords = [2, 4, 6];
      else if (SIZE === 13) starCoords = [3, 6, 9];
      else if (SIZE === 19) starCoords = [3, 9, 15];
      else return;
      for (const i of starCoords) {
        for (const j of starCoords) {
          const x = OFFSET + j * CELL;
          const y = OFFSET + i * CELL;
          ctx.beginPath();
          ctx.arc(x, y, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    function drawBoard() {
      const boardDiv = document.getElementById("board");
      document.querySelectorAll(".stone").forEach(s => s.remove());
      for (let i = 0; i < SIZE; i++) {
        for (let j = 0; j < SIZE; j++) {
          if (board[i][j] !== 0) {
            const stone = document.createElement("div");
            stone.classList.add("stone", board[i][j] === 1 ? "black" : "white");
            stone.style.left = (OFFSET + j * CELL) + "px";
            stone.style.top = (OFFSET + i * CELL) + "px";
            boardDiv.appendChild(stone);
          }
        }
      }
    }

    function saveState() {
      const boardCopy = board.map(row => [...row]);
      history.push({ board: boardCopy, turnCounter, moveMode, moveCount });
    }

    function undo() {
      if (history.length === 0) {
        alert("戻せる手はありません。");
        return;
      }
      const prev = history.pop();
      board = prev.board.map(row => [...row]);
      turnCounter = prev.turnCounter;
      moveMode = prev.moveMode;
      moveCount = prev.moveCount;
      drawBoard();
      updateTurnPhaseDisplay();
    }

    function updateTurnPhaseDisplay() {
      const turnPhase = document.getElementById("turnPhase");
      if (Math.floor(turnCounter) % 2 === 0) turnPhase.innerText = "黒の手番";
      else turnPhase.innerText = "白の手番";
    }

    function TurnPhase() {
      turnCounter += 1;
      updateTurnPhaseDisplay();
    }

    function placeStone(x, y) {
      const turn = document.getElementById("turnPhase").innerText;
      const player = turn === "黒の手番" ? 1 : 2;
      if (board[y][x] === 0) {
        saveState();
        board[y][x] = player;
        checkAndRemoveSurrounded(3 - player);
        drawBoard();
        TurnPhase();
      } else {
        alert("そこには置けません。");
      }
    }

    function toggleMoveMode() {
      moveMode = !moveMode;
      moveCount = 0;
      selectedStone = null;
      document.getElementById("moveControls").style.display = moveMode ? "block" : "none";
      alert(moveMode ? "石移動モード：自分の石を選んでください（最大2回まで移動可）。" : "通常モードに戻りました。");
    }
  document.getElementById("board").addEventListener("click", e => {
      const rect = document.getElementById("board").getBoundingClientRect();
      const xClick = e.clientX - rect.left - OFFSET;
      const yClick = e.clientY - rect.top - OFFSET;
      const x = Math.round(xClick / CELL);
      const y = Math.round(yClick / CELL);
      
      // 盤外クリックは無視
      if (x < 0 || x >= SIZE || y < 0 || y >= SIZE) return;

      const turn = document.getElementById("turnPhase").innerText;
      const player = turn === "黒の手番" ? 1 : 2;

      if (!moveMode) {
        // **【修正】通常モード:**
        // 座標(x, y)に石を配置する処理を呼び出す
        placeStone(x, y);
      } else {
        // **石移動モード:**
        if (board[y][x] === player) {
          // 自分の石を選択
          selectedStone = {x, y, player};
          alert(`選択中の石 (${x},${y})。方向を選んでください。`);
        } else {
          // 自分の石ではない
          alert("自分の石を選んでください。");
        }
      }
    });


    function moveSelectedStone(direction) {
      if (!selectedStone) return;
      const {x, y, player} = selectedStone;
      let nx = x, ny = y;

      if (direction === "W") ny -= 1;
      else if (direction === "S") ny += 1;
      else if (direction === "A") nx -= 1;
      else if (direction === "D") nx += 1;

      if (nx < 0 || nx >= SIZE || ny < 0 || ny >= SIZE) {
        alert("その方向には動かせません（盤外）。");
        return;
      }

      if (board[ny][nx] !== 0) {
        alert("その方向には石があります。動かせません。");
        return;
      }

      saveState();
      board[y][x] = 0;
      board[ny][nx] = player;
      checkAndRemoveSurrounded(3 - player);
      drawBoard();

      moveCount++;
      selectedStone = {x: nx, y: ny, player};

      if (moveCount >= 2) {
        moveMode = false;
        moveCount = 0;
        document.getElementById("moveControls").style.display = "none";
        TurnPhase();
        alert("2回移動しました。手番交代です。");
      } else {
        alert("もう一度1マス移動できます。");
      }
    }

    function checkAndRemoveSurrounded(targetPlayer) {
      const visited = Array.from({ length: SIZE }, () => Array(SIZE).fill(false));
      for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) {
          if (board[y][x] === targetPlayer && !visited[y][x]) {
            const group = [];
            const liberties = countLiberties(x, y, targetPlayer, visited, group);
            if (liberties === 0) {
              for (const {gx, gy} of group) board[gy][gx] = 0;
            }
          }
        }
      }
    }

    function countLiberties(x, y, player, visited, group) {
      const stack = [{x, y}];
      let liberties = 0;
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      while (stack.length > 0) {
        const {x, y} = stack.pop();
        if (visited[y][x]) continue;
        visited[y][x] = true;
        group.push({gx: x, gy: y});
        for (const [dx, dy] of dirs) {
          const nx = x + dx, ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= SIZE || ny >= SIZE) continue;
          if (board[ny][nx] === 0) liberties++;
          else if (board[ny][nx] === player && !visited[ny][nx]) stack.push({x: nx, y: ny});
        }
      }
      return liberties;
    }
  </script>
</body>
</html>
