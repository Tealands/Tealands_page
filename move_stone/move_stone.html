<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ç‰¹æ®Šå›²ç¢ - å¯¾å±€</title>
  <style>
    body {
      font-family: "Noto Sans JP", sans-serif;
      text-align: center;
      background-color: #f7f3e3;
    }
    #board {
      position: relative;
      margin: 20px auto;
      background-color: #f3d9a3;
      border: 2px solid #000;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }
    .stone {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      position: absolute;
      transform: translate(-50%, -50%);
      transition: 0.2s;
    }
    .black { background-color: black; }
    .white { background-color: white; border: 1px solid #000; }
    #turnPhase { font-size: 24px; margin: 10px; }
    #controls { margin-bottom: 10px; }
    button {
      font-size: 18px;
      padding: 6px 12px;
      margin: 5px;
    }
    #moveControls {
      display: none;
      margin: 15px;
    }
    #moveControls button {
      margin: 4px;
      font-size: 16px;
      padding: 5px 10px;
    }
  </style>
</head>
<body onload="initializeGame()">
  <div id="controls">
    <button onclick="toggleMoveMode()">çŸ³ç§»å‹•ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿</button>
    <button onclick="undo()">âª 1æ‰‹æˆ»ã™</button>
    <button onclick="goHome()">ğŸ  ãƒ›ãƒ¼ãƒ ã¸æˆ»ã‚‹</button>
  </div>

  <div id="board">
    <canvas id="grid"></canvas>
  </div>

  <div id="moveControls">
    <h3>ç§»å‹•æ–¹å‘ã‚’é¸æŠ</h3>
    <div>
      <button onclick="moveSelectedStone('W')">â†‘</button>
    </div>
    <div>
      <button onclick="moveSelectedStone('A')">â†</button>
      <button onclick="moveSelectedStone('D')">â†’</button>
    </div>
    <div>
      <button onclick="moveSelectedStone('S')">â†“</button>
    </div>
  </div>

  <div id="turnPhase">é»’ã®æ‰‹ç•ª</div>

  <script>
    let SIZE = 19;
    const CELL = 30;
    const OFFSET = CELL;
    let board = [];
    let selectedStone = null;
    let moveMode = false;
    let moveCount = 0; // 1ã‚¿ãƒ¼ãƒ³ä¸­ã®ç§»å‹•å›æ•°
    let turnCounter = 0;
    let history = [];

    function goHome() {
      if (confirm("å¯¾å±€ã‚’çµ‚äº†ã—ã¦ãƒ›ãƒ¼ãƒ ã¸æˆ»ã‚Šã¾ã™ã‹ï¼Ÿ")) {
        window.location.href = "title.html";
      }
    }

    function getBoardSizeFromURL() {
      const params = new URLSearchParams(window.location.search);
      const size = parseInt(params.get("size")) || 19;
      return [9, 13, 19].includes(size) ? size : 19;
    }

    function initializeGame() {
      SIZE = getBoardSizeFromURL();
      initializeBoard();
    }

    function initializeBoard() {
      board = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
      setupCanvas();
      drawGrid();
      drawBoard();
    }

    function setupCanvas() {
      const boardDiv = document.getElementById("board");
      const canvas = document.getElementById("grid");
      const length = (SIZE - 1) * CELL + OFFSET * 2 - CELL;
      boardDiv.style.width = length + "px";
      boardDiv.style.height = length + "px";
      canvas.width = length;
      canvas.height = length;
    }

    function drawGrid() {
      const canvas = document.getElementById("grid");
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#555";
      ctx.lineWidth = 1;
      const length = (SIZE - 1) * CELL + OFFSET * 2 - CELL;

      for (let i = 0; i < SIZE; i++) {
        const pos = OFFSET + i * CELL;
        ctx.beginPath();
        ctx.moveTo(OFFSET, pos);
        ctx.lineTo(length - OFFSET + CELL, pos);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(pos, OFFSET);
        ctx.lineTo(pos, length - OFFSET + CELL);
        ctx.stroke();
      }
      drawStars(ctx);
    }

    function drawStars(ctx) {
      ctx.fillStyle = "#000";
      let starCoords = [];
      if (SIZE === 9) starCoords = [2, 4, 6];
      else if (SIZE === 13) starCoords = [3, 6, 9];
      else if (SIZE === 19) starCoords = [3, 9, 15];
      else return;
      for (const i of starCoords) {
        for (const j of starCoords) {
          const x = OFFSET + j * CELL;
          const y = OFFSET + i * CELL;
          ctx.beginPath();
          ctx.arc(x, y, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    function drawBoard() {
      const boardDiv = document.getElementById("board");
      document.querySelectorAll(".stone").forEach(s => s.remove());
      for (let i = 0; i < SIZE; i++) {
        for (let j = 0; j < SIZE; j++) {
          if (board[i][j] !== 0) {
            const stone = document.createElement("div");
            stone.classList.add("stone", board[i][j] === 1 ? "black" : "white");
            stone.style.left = (OFFSET + j * CELL) + "px";
            stone.style.top = (OFFSET + i * CELL) + "px";
            boardDiv.appendChild(stone);
          }
        }
      }
    }

    function saveState() {
      const boardCopy = board.map(row => [...row]);
      history.push({ board: boardCopy, turnCounter, moveMode, moveCount });
    }

    function undo() {
      if (history.length === 0) {
        alert("æˆ»ã›ã‚‹æ‰‹ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚");
        return;
      }
      const prev = history.pop();
      board = prev.board.map(row => [...row]);
      turnCounter = prev.turnCounter;
      moveMode = prev.moveMode;
      moveCount = prev.moveCount;
      drawBoard();
      updateTurnPhaseDisplay();
    }

    function updateTurnPhaseDisplay() {
      const turnPhase = document.getElementById("turnPhase");
      if (Math.floor(turnCounter) % 2 === 0) turnPhase.innerText = "é»’ã®æ‰‹ç•ª";
      else turnPhase.innerText = "ç™½ã®æ‰‹ç•ª";
    }

    function TurnPhase() {
      turnCounter += 1;
      updateTurnPhaseDisplay();
    }

    function placeStone(x, y) {
      const turn = document.getElementById("turnPhase").innerText;
      const player = turn === "é»’ã®æ‰‹ç•ª" ? 1 : 2;
      if (board[y][x] === 0) {
        saveState();
        board[y][x] = player;
        checkAndRemoveSurrounded(3 - player);
        drawBoard();
        TurnPhase();
      } else {
        alert("ãã“ã«ã¯ç½®ã‘ã¾ã›ã‚“ã€‚");
      }
    }

    function toggleMoveMode() {
      moveMode = !moveMode;
      moveCount = 0;
      selectedStone = null;
      document.getElementById("moveControls").style.display = moveMode ? "block" : "none";
      alert(moveMode ? "çŸ³ç§»å‹•ãƒ¢ãƒ¼ãƒ‰ï¼šè‡ªåˆ†ã®çŸ³ã‚’é¸ã‚“ã§ãã ã•ã„ï¼ˆæœ€å¤§2å›ã¾ã§ç§»å‹•å¯ï¼‰ã€‚" : "é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã‚Šã¾ã—ãŸã€‚");
    }
  document.getElementById("board").addEventListener("click", e => {
      const rect = document.getElementById("board").getBoundingClientRect();
      const xClick = e.clientX - rect.left - OFFSET;
      const yClick = e.clientY - rect.top - OFFSET;
      const x = Math.round(xClick / CELL);
      const y = Math.round(yClick / CELL);
      
      // ç›¤å¤–ã‚¯ãƒªãƒƒã‚¯ã¯ç„¡è¦–
      if (x < 0 || x >= SIZE || y < 0 || y >= SIZE) return;

      const turn = document.getElementById("turnPhase").innerText;
      const player = turn === "é»’ã®æ‰‹ç•ª" ? 1 : 2;

      if (!moveMode) {
        // **ã€ä¿®æ­£ã€‘é€šå¸¸ãƒ¢ãƒ¼ãƒ‰:**
        // åº§æ¨™(x, y)ã«çŸ³ã‚’é…ç½®ã™ã‚‹å‡¦ç†ã‚’å‘¼ã³å‡ºã™
        placeStone(x, y);
      } else {
        // **çŸ³ç§»å‹•ãƒ¢ãƒ¼ãƒ‰:**
        if (board[y][x] === player) {
          // è‡ªåˆ†ã®çŸ³ã‚’é¸æŠ
          selectedStone = {x, y, player};
          alert(`é¸æŠä¸­ã®çŸ³ (${x},${y})ã€‚æ–¹å‘ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚`);
        } else {
          // è‡ªåˆ†ã®çŸ³ã§ã¯ãªã„
          alert("è‡ªåˆ†ã®çŸ³ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚");
        }
      }
    });


    function moveSelectedStone(direction) {
      if (!selectedStone) return;
      const {x, y, player} = selectedStone;
      let nx = x, ny = y;

      if (direction === "W") ny -= 1;
      else if (direction === "S") ny += 1;
      else if (direction === "A") nx -= 1;
      else if (direction === "D") nx += 1;

      if (nx < 0 || nx >= SIZE || ny < 0 || ny >= SIZE) {
        alert("ãã®æ–¹å‘ã«ã¯å‹•ã‹ã›ã¾ã›ã‚“ï¼ˆç›¤å¤–ï¼‰ã€‚");
        return;
      }

      if (board[ny][nx] !== 0) {
        alert("ãã®æ–¹å‘ã«ã¯çŸ³ãŒã‚ã‚Šã¾ã™ã€‚å‹•ã‹ã›ã¾ã›ã‚“ã€‚");
        return;
      }

      saveState();
      board[y][x] = 0;
      board[ny][nx] = player;
      checkAndRemoveSurrounded(3 - player);
      drawBoard();

      moveCount++;
      selectedStone = {x: nx, y: ny, player};

      if (moveCount >= 2) {
        moveMode = false;
        moveCount = 0;
        document.getElementById("moveControls").style.display = "none";
        TurnPhase();
        alert("2å›ç§»å‹•ã—ã¾ã—ãŸã€‚æ‰‹ç•ªäº¤ä»£ã§ã™ã€‚");
      } else {
        alert("ã‚‚ã†ä¸€åº¦1ãƒã‚¹ç§»å‹•ã§ãã¾ã™ã€‚");
      }
    }

    function checkAndRemoveSurrounded(targetPlayer) {
      const visited = Array.from({ length: SIZE }, () => Array(SIZE).fill(false));
      for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) {
          if (board[y][x] === targetPlayer && !visited[y][x]) {
            const group = [];
            const liberties = countLiberties(x, y, targetPlayer, visited, group);
            if (liberties === 0) {
              for (const {gx, gy} of group) board[gy][gx] = 0;
            }
          }
        }
      }
    }

    function countLiberties(x, y, player, visited, group) {
      const stack = [{x, y}];
      let liberties = 0;
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      while (stack.length > 0) {
        const {x, y} = stack.pop();
        if (visited[y][x]) continue;
        visited[y][x] = true;
        group.push({gx: x, gy: y});
        for (const [dx, dy] of dirs) {
          const nx = x + dx, ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= SIZE || ny >= SIZE) continue;
          if (board[ny][nx] === 0) liberties++;
          else if (board[ny][nx] === player && !visited[ny][nx]) stack.push({x: nx, y: ny});
        }
      }
      return liberties;
    }
  </script>
</body>
</html>
